---
layout: post
title:  "Reading04: Objects and Types and Macros OH MY!"
date:   2019-02-19 18:20:00 -0500
categories: hackers post
---

**How important is the choice of programming language in software development and computer science? What is lacking in our current set of tools? What ideas or features will continue to persist far into the future?**

If I am going into the kitchen to cook dinner there a few things that I absolutly need to make a good meal. The first thing is the right ingredents...this is obvious, without chicken I am not going to make *Chicken Fran√ßaise*[^1]. It is the same with programming a computer without the right ideas of how to acomplish the task I want to acomplish it will be awfuly hard to get my task done. Maybe something you didn't think about is the tools that one needs to cook in the kitchen. Without a proper frying pan one could never hope to fry up chicken, taking that slightly further a good seasoned cast iron pan will lead to unbelievebaly delicious chicken. Without exactly the right tool in the kitchen you have to modify how you go about cooking your food to match what you have. It is not much of a stretch to see how this translates exactly to computer science. Your "tools" in programming are your programming languages. Each one has a prupose and each one offers advantages and disadvantages over one another. More importantly, just as in the kitchen, which language you use impacts how you go about thinking about the problem you are solving. One very clear example of this that Graham refers to is types: with a strongly typed language after you have chosen a type for a peice of data it can be tedious to go back and change the type, with dynamically typed languages on the other hand what types your variables are can easily be fluid allowing more flexibility and free thinking. 

Graham advocates that people get stuck programming in languages that are less than optimal, that in fact, "Industry Best Practice" in software engineering only yields average code. I tend to agree with this statement only going off of the little experience I have with learning new languages. When I first learned python I always found myself comparing it to what I knew which at the time was C/C++; it blew my mind how much power python had in relativly few lines allowing me to get things done faster and in less lines of code. If just the language had this much more abstraction over C/C++ I can only imagine what other lanauges out there can do. The issue here is getting people to take the time to invest in them an learn them. Personally Paul Graham has convined me, I am going to do my best to learn LISP if only to be able to see if it is just as powerful as Paul Graham says it is[^2]. Getting into a rut using the same language that we are used to is easy to do, we convince ourselves that yes what we are doing is the best because we know it well and can get things done in it quickly. This thinking is misleading though; how can we possibly know about languages we haven't learned yet!? It is exactly for this reason that it is important to stay up to date on new languages and to make a point to at least implement one medium sized project in every new language you learn. Doing this will allow you to see if the language truly is more powerful than another and allows you to see what features are carried over from your favorite language and which are new (and possibly more useful). 

Overall what features are lacking in programming languages now is hard for me to tell immediatly since I have experince with only a very limited sub-set of languages, but I can say that in the future new languages will continue to borrow ideas from old languages that people find popular. Maybe in the future languages will adopt all of the features that Graham claims LSIP has with better syntax in order to make it more appealing to the masses. While some languages will 100% die out as Graham suggests it is clear that some languages will also stick around, it seems to me that while C/C++ are low level they will stick around for that very reason...we need low level access to write system code and things that run closer to the hardware. Other languages I would imagine will get ever more high level as computers get faster and faster and can handle less than optimal or "slow" languages. This could lead to even more powerful languages being developed that we haden't even thought of in the past or present or that were not possible with how currnetly fast our computers are. 

[^1]: [Recipe](https://www.allrecipes.com/recipe/16681/delicious-easy-chicken-francese/)
[^2]: I'll Let You All Know How This Goes...